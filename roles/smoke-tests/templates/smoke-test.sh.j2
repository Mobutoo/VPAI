#!/bin/bash
# {{ ansible_managed }}
# Smoke tests for {{ project_display_name }}
# Usage: {{ smoke_test_script_path }}
# Exit code: 0 = all tests passed, 1 = at least one test failed

set -euo pipefail

BASE_URL="{{ smoke_test_base_url }}"
ADMIN_URL="{{ smoke_test_admin_url }}"
{% if n8n_subdomain | default('') | length > 0 %}
N8N_URL="https://{{ n8n_subdomain }}.{{ domain_name }}"
{% else %}
N8N_URL="${ADMIN_URL}/n8n"
{% endif %}
TIMEOUT="{{ smoke_test_timeout }}"
PROJECT="{{ project_name }}"
FAILURES=0

# VPN-protected admin services: resolve admin domains via Tailscale IP
# so Caddy sees a VPN source IP (in {{ caddy_vpn_cidr }}) instead of Docker gateway IP
TAILSCALE_IP=$(tailscale ip -4 2>/dev/null || echo "")
CURL_VPN_OPTS=""
if [ -n "${TAILSCALE_IP}" ]; then
  CURL_VPN_OPTS="--resolve {{ admin_subdomain | default('admin') }}.{{ domain_name }}:443:${TAILSCALE_IP}"
{% if n8n_subdomain | default('') | length > 0 %}
  CURL_VPN_OPTS="${CURL_VPN_OPTS} --resolve {{ n8n_subdomain }}.{{ domain_name }}:443:${TAILSCALE_IP}"
{% endif %}
  echo "INFO  Using Tailscale IP ${TAILSCALE_IP} for VPN-protected endpoints"
else
  echo "WARN  Tailscale not available — VPN-protected endpoint tests may fail"
fi

check_http() {
  local name="$1" url="$2" expected="${3:-200}"
  local status
  # shellcheck disable=SC2086
  status=$(curl -sL -o /dev/null -w "%{http_code}" --max-time "${TIMEOUT}" ${CURL_VPN_OPTS} "$url" 2>/dev/null) || status="000"
  if [ "$status" = "$expected" ]; then
    echo "PASS  $name (HTTP $status)"
  else
    echo "FAIL  $name (HTTP $status, expected $expected)"
    FAILURES=$((FAILURES + 1))
  fi
}

check_container() {
  local name="$1" container="$2"
  local state
  state=$(docker inspect --format='{{ '{{' }}.State.Status{{ '}}' }}' "${PROJECT}_${container}" 2>/dev/null) || state="not_found"
  if [ "$state" = "running" ]; then
    echo "PASS  $name container (running)"
  else
    echo "FAIL  $name container (state: $state)"
    FAILURES=$((FAILURES + 1))
  fi
}

check_container_health() {
  local name="$1" container="$2"
  local health
  health=$(docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}' "${PROJECT}_${container}" 2>/dev/null) || health="unknown"
  if [ "$health" = "healthy" ]; then
    echo "PASS  $name healthcheck (healthy)"
  else
    echo "FAIL  $name healthcheck ($health)"
    FAILURES=$((FAILURES + 1))
  fi
}

echo "============================================"
echo "  Smoke Tests - {{ project_display_name }}"
echo "  $(date)"
echo "  Target: ${BASE_URL}"
echo "============================================"
echo ""

# === HTTPS & TLS ===
echo "--- HTTPS & TLS ---"
check_http "Caddy HTTPS health" "${BASE_URL}/health"

# Check TLS certificate validity
TLS_EXPIRY=$(echo | openssl s_client -servername "{{ domain_name }}" -connect "{{ domain_name }}:443" 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2) || TLS_EXPIRY=""
if [ -n "${TLS_EXPIRY}" ]; then
  EXPIRY_EPOCH=$(date -d "${TLS_EXPIRY}" +%s 2>/dev/null) || EXPIRY_EPOCH=0
  NOW_EPOCH=$(date +%s)
  DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))
  if [ "${DAYS_LEFT}" -gt 7 ]; then
    echo "PASS  TLS certificate (expires in ${DAYS_LEFT} days)"
  else
    echo "FAIL  TLS certificate (expires in ${DAYS_LEFT} days)"
    FAILURES=$((FAILURES + 1))
  fi
else
  echo "FAIL  TLS certificate (could not check)"
  FAILURES=$((FAILURES + 1))
fi

# Check DNS resolution (use getent — available everywhere, dig may not be installed)
DNS_RESULT=$(getent hosts "{{ domain_name }}" 2>/dev/null | awk '{print $1}' | head -1) || DNS_RESULT=""
if [ -n "${DNS_RESULT}" ]; then
  echo "PASS  DNS resolution ({{ domain_name }} -> ${DNS_RESULT})"
else
  echo "FAIL  DNS resolution ({{ domain_name }} not resolving)"
  FAILURES=$((FAILURES + 1))
fi

echo ""

# === APPLICATION HEALTH ===
echo "--- Application Endpoints ---"
check_http "n8n healthz" "${N8N_URL}/healthz"
check_http "Grafana health" "${ADMIN_URL}/grafana/api/health"
check_http "LiteLLM health" "${BASE_URL}/litellm/health"

echo ""

# === CONTAINER STATUS ===
echo "--- Container Status ---"
check_container "PostgreSQL" "postgresql"
check_container "Redis" "redis"
check_container "Qdrant" "qdrant"
check_container "n8n" "n8n"
check_container "LiteLLM" "litellm"
check_container "OpenClaw" "openclaw"
check_container "Caddy" "caddy"
check_container "VictoriaMetrics" "victoriametrics"
check_container "Loki" "loki"
check_container "Alloy" "alloy"
check_container "Grafana" "grafana"
check_container "DIUN" "diun"

echo ""

# === CONTAINER HEALTHCHECKS ===
echo "--- Container Health ---"
check_container_health "PostgreSQL" "postgresql"
check_container_health "Redis" "redis"
check_container_health "Qdrant" "qdrant"
check_container_health "n8n" "n8n"
check_container_health "LiteLLM" "litellm"
check_container_health "Caddy" "caddy"
check_container_health "VictoriaMetrics" "victoriametrics"
check_container_health "Loki" "loki"
check_container_health "Grafana" "grafana"

echo ""

# === DATABASE CONNECTIVITY ===
echo "--- Database Connectivity ---"

# PostgreSQL
PG_READY=$(docker exec "${PROJECT}_postgresql" pg_isready -U postgres 2>/dev/null) && PG_RC=0 || PG_RC=1
if [ "${PG_RC}" -eq 0 ]; then
  echo "PASS  PostgreSQL connectivity (pg_isready)"
else
  echo "FAIL  PostgreSQL connectivity"
  FAILURES=$((FAILURES + 1))
fi

# Redis
REDIS_PING=$(docker exec "${PROJECT}_redis" redis-cli -a "{{ redis_password }}" ping 2>/dev/null) || REDIS_PING=""
if [ "${REDIS_PING}" = "PONG" ]; then
  echo "PASS  Redis connectivity (PONG)"
else
  echo "FAIL  Redis connectivity (got: ${REDIS_PING})"
  FAILURES=$((FAILURES + 1))
fi

# Qdrant
QDRANT_HEALTH=$(docker exec "${PROJECT}_qdrant" bash -c ':> /dev/tcp/localhost/6333' 2>/dev/null) && QDRANT_RC=0 || QDRANT_RC=1
if [ "${QDRANT_RC}" -eq 0 ]; then
  echo "PASS  Qdrant connectivity"
else
  echo "FAIL  Qdrant connectivity"
  FAILURES=$((FAILURES + 1))
fi

echo ""

# === LiteLLM API ===
echo "--- LiteLLM API ---"
MODELS=$(curl -s -H "Authorization: Bearer {{ litellm_master_key }}" \
  "${BASE_URL}/litellm/v1/models" --max-time "${TIMEOUT}" 2>/dev/null | \
  grep -o '"id"' | wc -l) || MODELS=0
if [ "${MODELS}" -gt 0 ]; then
  echo "PASS  LiteLLM models (${MODELS} models available)"
else
  echo "FAIL  LiteLLM models (no models found)"
  FAILURES=$((FAILURES + 1))
fi

echo ""

# === SERVICE PROVISIONING ===
echo "--- Service Provisioning ---"

# n8n owner provisioned (check if setup page is gone)
# shellcheck disable=SC2086
N8N_SETTINGS=$(curl -s ${CURL_VPN_OPTS} "${N8N_URL}/rest/settings" --max-time "${TIMEOUT}" 2>/dev/null || echo '{}')
N8N_SETUP_PAGE=$(echo "$N8N_SETTINGS" | grep -o '"showSetupPage":[a-z]*' | cut -d: -f2 || echo "unknown")
if [ "$N8N_SETUP_PAGE" = "false" ]; then
  echo "PASS  n8n owner provisioned (setup complete)"
elif [ "$N8N_SETUP_PAGE" = "true" ]; then
  echo "WARN  n8n owner NOT provisioned (setup page still showing)"
else
  echo "SKIP  n8n owner check (could not determine setup state)"
fi

# LiteLLM UI accessible (on public domain, behind API key auth)
check_http "LiteLLM UI" "${BASE_URL}/litellm/ui/" "200"

# Grafana login possible (just check the login page loads)
check_http "Grafana login page" "${ADMIN_URL}/grafana/login" "200"

echo ""

# === RESULTS ===
echo "============================================"
if [ "${FAILURES}" -eq 0 ]; then
  echo "  ALL TESTS PASSED"
  echo "============================================"
  exit 0
else
  echo "  ${FAILURES} TEST(S) FAILED"
  echo "============================================"
  exit 1
fi
