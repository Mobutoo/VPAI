{
    admin localhost:2019
    email {{ caddy_notification_email }}
    servers {
        protocols h1 h2 h3
        # === TRUSTED PROXIES ===
        # CRITIQUE: Sans trusted_proxies, Caddy utilise remote_ip = IP TCP directe.
        # En Docker bridge avec DNAT, remote_ip = IP reelle du client (DNAT preserve la source).
        #
        # Scenario 1 - Client VPN (Tailscale) + Split DNS :
        #   Client Tailscale -> IP VPN 100.64.x.x -> port 443 VPS -> Docker DNAT -> Caddy
        #   remote_ip = 100.64.x.x (DNAT ne change PAS la source)
        #   client_ip = idem (pas de proxy intermediaire)
        #
        # Scenario 2 - Client VPN SANS Split DNS (BUG VECU) :
        #   Client -> DNS public -> IP publique VPS -> Caddy
        #   remote_ip = IP publique du client (PAS dans 100.64.0.0/10) -> bloque!
        #   -> SPLIT DNS OBLIGATOIRE (voir headscale-node role)
        #
        # Scenario 3 - Webhook relay via Seko-VPN (mode VPN-only) :
        #   Meta -> hook.<domain> (Seko-VPN) -> reverse proxy via mesh -> VPS Caddy
        #   Les webhooks n'arrivent plus sur ce Caddy directement depuis Internet.
        #   Ils sont relayés par Seko-VPN via Tailscale IP -> Docker DNAT -> Caddy.
        #   remote_ip = IP Tailscale de Seko-VPN (dans 100.64.0.0/10)
        #
        # REX: trusted_proxies requis pour que client_ip fonctionne correctement.
        # On trust private_ranges car Docker est en reseau local.
        trusted_proxies static private_ranges
    }
    log {
        output file /var/log/caddy/access.log {
            roll_size 50MiB
            roll_keep 3
            roll_keep_for 168h
        }
        format json
        level INFO
    }
{% if caddy_acme_dns01 | default(false) | bool or caddy_vpn_only_mode | default(false) | bool %}
    # DNS-01 ACME challenge via OVH — port 80 non requis
    # REX: Utiliser DNS-01 quand le port 80 est ferme (mode VPN-only).
    # Les credentials OVH sont injectes via variables d'environnement Docker
    # (OVH_APPLICATION_KEY, OVH_APPLICATION_SECRET, OVH_CONSUMER_KEY, OVH_ENDPOINT).
    acme_dns ovh {
        endpoint {$OVH_ENDPOINT}
        application_key {$OVH_APPLICATION_KEY}
        application_secret {$OVH_APPLICATION_SECRET}
        consumer_key {$OVH_CONSUMER_KEY}
    }
{% endif %}
}

{% if caddy_vpn_enforce | default(true) | bool %}
(vpn_only) {
    # REX: Caddy dans Docker (réseau frontend 172.20.1.0/24) reçoit les connexions
    # Tailscale avec client_ip = 172.20.1.1 (gateway Docker bridge, DNAT via UDP/QUIC).
    # Les deux CIDRs sont autorisés :
    #   - {{ caddy_vpn_cidr }} : IP Tailscale directes (TCP/HTTP2)
    #   - {{ caddy_docker_frontend_cidr }} : gateway Docker bridge (HTTP/3 QUIC via DNAT)
    # Ces plages sont inatteignables depuis Internet → pas de risque d'usurpation.
    @blocked not client_ip {{ caddy_vpn_cidr }} {{ caddy_docker_frontend_cidr }}
    error @blocked 403
}

(vpn_error_page) {
    handle_errors {
        root * /srv
        rewrite * /restricted-zone.html
        file_server
    }
}
{% else %}
# VPN enforcement DISABLED (caddy_vpn_enforce=false)
# Admin UIs are publicly accessible - for initial validation only
(vpn_only) {
}
(vpn_error_page) {
}
{% endif %}

# === PUBLIC DOMAIN - Admin Portal ===
{{ caddy_domain }} {
    # /health endpoint — VPN-only quand le mode est active (Uptime Kuma est sur le mesh)
    # Mode public : accessible depuis Internet (smoke tests, monitoring externe)
    # Mode VPN-only : accessible uniquement via Tailscale (Uptime Kuma via mesh)
    handle /health {
{% if caddy_vpn_enforce | default(true) | bool and (caddy_vpn_only_mode | default(false) | bool) %}
        @blocked_health not client_ip {{ caddy_vpn_cidr }}
        error @blocked_health 403
{% endif %}
        respond "OK" 200
    }

{% if caddy_webhook_relay | default(false) | bool or caddy_vpn_only_mode | default(false) | bool %}
    # VPN-ONLY MODE : webhooks Meta relayés via Seko-VPN (webhook relay)
    # Architecture : Meta -> hook.<domain> (Seko-VPN) -> reverse proxy via mesh -> VPS Caddy -> n8n
    # Ces paths recoivent le trafic depuis Seko-VPN (IP Tailscale dans 100.64.0.0/10).
    # Le relay est auto-hébergé (100% infra propre, zero tiers).
{% for path in caddy_public_webhook_paths | default([]) %}
    handle {{ path }} {
        reverse_proxy n8n:5678
    }
{% endfor %}
{% endif %}

    # Admin portal (catch-all) - VPN-protected
    # REX: Utiliser les deux CIDRs comme dans le snippet vpn_only :
    # caddy_vpn_cidr (Tailscale TCP) + caddy_docker_frontend_cidr (HTTP/3 QUIC via DNAT Docker)
    handle {
{% if caddy_vpn_enforce | default(true) | bool %}
        @blocked_root not client_ip {{ caddy_vpn_cidr }} {{ caddy_docker_frontend_cidr }}
        error @blocked_root 403
{% endif %}
        root * /srv
        rewrite * /admin-landing.html
        file_server
    }

{% if caddy_vpn_enforce | default(true) | bool %}
    import vpn_error_page
{% endif %}

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "DENY"
        Referrer-Policy "strict-origin-when-cross-origin"
        -Server
    }
}

# === OpenClaw - dedicated subdomain (javisi) ===
# OpenClaw Gateway (Control UI + WebSocket on port 18789)
# basePath=/ - Gateway serves UI at root of its own subdomain
#
# REX: OpenClaw Control UI stores the gateway token in browser localStorage.
# On first access, localStorage is empty -> WebSocket rejected -> "token missing" loop.
# The /__bootstrap__ route injects the token into localStorage and redirects to /.
# This route is VPN-protected like the rest. First-time setup:
#   open https://{{ caddy_admin_domain }}/__bootstrap__
{{ caddy_admin_domain }} {
    import vpn_only
    import vpn_error_page

    # Token bootstrap - first-time Control UI setup (sets localStorage token)
    handle /__bootstrap__ {
        header Content-Type "text/html; charset=utf-8"
        respond <<BOOTSTRAP
<!DOCTYPE html><html><head><meta charset="utf-8"><title>OpenClaw Setup</title></head><body style="background:#1a1a2e;color:#eee;font-family:sans-serif;display:flex;align-items:center;justify-content:center;height:100vh;margin:0"><div style="text-align:center"><h2>OpenClaw Gateway</h2><p id="msg">Configuring token...</p><script>try{let s=JSON.parse(localStorage.getItem('openclaw.control.settings.v1')||'{}');s.token='{{ openclaw_gateway_token }}';s.gatewayUrl='wss://{{ caddy_admin_domain }}';localStorage.setItem('openclaw.control.settings.v1',JSON.stringify(s));document.getElementById('msg').textContent='Token configured. Redirecting...';setTimeout(()=>window.location.href='/',500)}catch(e){document.getElementById('msg').textContent='Error: '+e.message}</script></div></body></html>
BOOTSTRAP 200
    }

    # HTTP/1.1 requis pour WebSocket upgrade (RFC 6455)
    # HTTP/2 ignore le header "Upgrade: websocket" -> connexion WS impossible
    reverse_proxy openclaw:18789 {
        transport http {
            versions 1.1
        }
    }

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        -Server
    }
}

# === Grafana - dedicated subdomain (tala) ===
# REX: Grafana on its own subdomain - no need for SERVE_FROM_SUB_PATH
{% if grafana_subdomain | default('') | length > 0 %}
{{ caddy_grafana_domain }} {
    import vpn_only
    import vpn_error_page

    reverse_proxy grafana:3000

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        -Server
    }
}
{% endif %}

# === n8n - dedicated subdomain ===
# REX: n8n does NOT support sub-path deployment (GitHub issue #19635)
{% if n8n_subdomain | default('') | length > 0 %}
{{ caddy_n8n_domain }} {
    import vpn_only
    import vpn_error_page

    reverse_proxy n8n:5678

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        -Server
    }
}
{% endif %}

# === LiteLLM - dedicated subdomain ===
# REX: LiteLLM UI does NOT support sub-path (SERVER_ROOT_PATH buggy: issues #11451, #11865)
{% if litellm_subdomain | default('') | length > 0 %}
{{ caddy_litellm_domain }} {
    import vpn_only
    import vpn_error_page

    reverse_proxy litellm:4000

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        -Server
    }
}
{% endif %}

# === Qdrant - dedicated subdomain ===
# REX: Qdrant dashboard does NOT support sub-path (qdrant-web-ui issue #94, open since 2023)
{% if qdrant_subdomain | default('') | length > 0 %}
{{ caddy_qdrant_domain }} {
    import vpn_only
    import vpn_error_page

    reverse_proxy qdrant:6333

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        -Server
    }
}
{% endif %}

# Kaneo block supprimé — remplacé par Palais (Phase 16)

# === Palais — Cockpit IA Afrofuturiste ===
{{ caddy_palais_domain }} {
    import vpn_only
    import vpn_error_page

    reverse_proxy palais:{{ palais_port | default(3300) }}
}

# === Sure (personal finance) — dedicated subdomain (nzimbu) ===
{% if sure_subdomain | default('') | length > 0 %}
{{ caddy_sure_domain }} {
    import vpn_only
    import vpn_error_page

    reverse_proxy sure-web:{{ sure_web_port | default(3000) }}

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        -Server
    }
}
{% endif %}

# === NocoDB — pipeline production IA manga (hq.<domain>) ===
{% if nocodb_subdomain | default('') | length > 0 %}
{{ caddy_nocodb_domain }} {
    import vpn_only
    import vpn_error_page

    reverse_proxy nocodb:8080

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        -Server
    }
}
{% endif %}

# === Plane — Operational Intelligence Hub (work.<domain>) ===
# CRITICAL: Public webhook endpoint for n8n integration (INFRA-04)
# Handle ordering: /webhooks/plane MUST appear BEFORE VPN matcher to avoid 403
work.{{ domain_name }} {
    # CRITICAL: Public webhook endpoint for n8n integration (INFRA-04)
    # Must be BEFORE VPN-only block to avoid 403 on webhook delivery
    handle /webhooks/plane {
        reverse_proxy n8n:5678
    }

    # VPN-only access with 2-CIDR rule (CRITICAL: both VPN and Docker frontend)
    @blocked_plane {
        not client_ip {{ caddy_vpn_cidr }} {{ caddy_docker_frontend_cidr }}
    }
    handle @blocked_plane {
        error 403
    }

    # Plane API endpoints (VPN-only)
    handle /api/* {
        reverse_proxy plane-api:8000
    }

    handle /auth/* {
        reverse_proxy plane-api:8000
    }

    # MinIO file uploads — presigned POST URLs (REX 2026-03-01)
    # Plane génère des URLs presignées pointant vers /plane/... (bucket dans le path)
    # endpoint_url = https://work.ewutelo.cloud → URL = https://work.ewutelo.cloud/plane
    # Caddy doit router /plane/* directement vers MinIO sans strip_prefix
    handle /plane* {
        reverse_proxy plane-minio:9000
    }

    # Legacy /uploads/* handler (rétrocompatibilité si des liens anciens existent)
    handle /uploads/* {
        uri strip_prefix /uploads
        reverse_proxy plane-minio:9000
    }

    # Plane web UI - catch-all (VPN-only)
    handle {
        reverse_proxy plane-web:3000
    }

    import vpn_error_page

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        -Server
    }
}

# === CouchDB (Obsidian LiveSync) — Public HTTPS, auth CouchDB ===
# REX: CORS origins=* obligatoire pour obsidian-livesync (cross-origin depuis l'app iOS/PC)
# Pas d'import vpn_only — CouchDB est intentionnellement public pour sync iOS sans VPN.
# L'auth est gérée par CouchDB natif (user/password configuré dans le plugin Obsidian).
# Pour basculer en VPN-only : couchdb_vpn_enforce: true dans group_vars/all/main.yml
# CouchDB tourne sur Seko-VPN, accessible depuis Sese-AI via le mesh Tailscale (vpn_tailscale_ip).
{% if obsidian_subdomain | default('') | length > 0 %}
{{ obsidian_subdomain }}.{{ domain_name }} {
{% if couchdb_vpn_enforce | default(false) | bool %}
    # Mode VPN-only : restreindre aux IPs Tailscale + gateway Docker (HTTP/3 QUIC)
    @blocked_couch not client_ip {{ caddy_vpn_cidr }} {{ caddy_docker_frontend_cidr }}
    error @blocked_couch 403
{% endif %}
    reverse_proxy {{ vpn_tailscale_ip }}:{{ couchdb_port | default(5984) }} {
        header_up Host {host}
    }
    header {
        Access-Control-Allow-Origin *
        Access-Control-Allow-Methods "GET, PUT, POST, HEAD, DELETE, OPTIONS"
        Access-Control-Allow-Headers "accept, authorization, content-type, origin, referer, x-csrf-token"
        Access-Control-Allow-Credentials true
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        -Server
    }
}
{% endif %}
