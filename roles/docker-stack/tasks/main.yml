---
# docker-stack — tasks
# Deploie la stack Docker en phases isolees avec healthchecks individuels
# Chaque service est verifie separement pour faciliter le troubleshooting

- name: Create project directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ prod_user }}"
    group: "{{ prod_user }}"
    mode: "0755"
  loop:
    - "/opt/{{ project_name }}"
    - "/opt/{{ project_name }}/logs/caddy"
    - "/opt/{{ project_name }}/scripts"
  become: true

# === CLEANUP : Stop Phase B apps before redeploy (infra stays running) ===
- name: Stop Phase B apps stack if it exists
  ansible.builtin.shell:
    executable: /bin/bash
    cmd: |
      set -o pipefail
      cd /opt/{{ project_name }}
      if [ -f docker-compose.yml ]; then
        docker compose -f docker-compose.yml down --remove-orphans 2>/dev/null || true
      fi
  become: true
  changed_when: false
  failed_when: false

# === PHASE A : INFRASTRUCTURE (all services start independently) ===
- name: Deploy docker-compose-infra.yml template
  ansible.builtin.template:
    src: docker-compose-infra.yml.j2
    dest: "/opt/{{ project_name }}/docker-compose-infra.yml"
    owner: "{{ prod_user }}"
    group: "{{ prod_user }}"
    mode: "0644"
  become: true

- name: Start Infrastructure stack (Phase A)
  community.docker.docker_compose_v2:
    project_src: "/opt/{{ project_name }}"
    files:
      - docker-compose-infra.yml
    state: present
  become: true
  register: docker_infra_result
  failed_when: false

- name: Show Phase A errors if any
  ansible.builtin.debug:
    msg: >-
      Phase A returned: {{ docker_infra_result.msg | default('OK') }}
  when: docker_infra_result.failed | default(false)

# === INDIVIDUAL HEALTH CHECKS (with diagnostic logs on failure) ===

# --- PostgreSQL ---
- name: Wait for PostgreSQL to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_postgresql
  register: pg_health
  changed_when: false
  retries: 20
  delay: 5
  until: pg_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show PostgreSQL logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_postgresql --tail 30"
  become: true
  changed_when: false
  when: pg_health.stdout | default('') != 'healthy'

- name: Fail if PostgreSQL is unhealthy
  ansible.builtin.fail:
    msg: "PostgreSQL failed to become healthy. Check logs above."
  when: pg_health.stdout | default('') != 'healthy'

# --- PostgreSQL provisioning (idempotent — creates DBs/users if missing) ---
# REX: init.sql only runs on FIRST PostgreSQL initialization (empty data dir)
# Subsequent deploys need explicit provisioning for new databases/users
- name: Deploy PostgreSQL provisioning script
  ansible.builtin.template:
    src: provision-postgresql.sh.j2
    dest: "/opt/{{ project_name }}/scripts/provision-postgresql.sh"
    owner: "{{ prod_user }}"
    group: "{{ prod_user }}"
    mode: "0750"
  become: true

- name: Provision PostgreSQL databases and users
  ansible.builtin.command:
    cmd: "/opt/{{ project_name }}/scripts/provision-postgresql.sh"
  become: true
  register: pg_provision
  changed_when: "'Creating' in pg_provision.stdout"

- name: Show PostgreSQL provisioning output
  ansible.builtin.debug:
    msg: "{{ pg_provision.stdout_lines }}"
  when: pg_provision.stdout_lines | default([]) | length > 0

# --- Redis ---
- name: Wait for Redis to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_redis
  register: redis_health
  changed_when: false
  retries: 10
  delay: 3
  until: redis_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show Redis logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_redis --tail 30"
  become: true
  changed_when: false
  when: redis_health.stdout | default('') != 'healthy'

- name: Fail if Redis is unhealthy
  ansible.builtin.fail:
    msg: "Redis failed to become healthy. Check logs above."
  when: redis_health.stdout | default('') != 'healthy'

# --- Qdrant ---
- name: Wait for Qdrant to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_qdrant
  register: qdrant_health
  changed_when: false
  retries: 10
  delay: 3
  until: qdrant_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show Qdrant logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_qdrant --tail 30"
  become: true
  changed_when: false
  when: qdrant_health.stdout | default('') != 'healthy'

- name: Fail if Qdrant is unhealthy
  ansible.builtin.fail:
    msg: "Qdrant failed to become healthy. Check logs above."
  when: qdrant_health.stdout | default('') != 'healthy'

# --- Caddy ---
- name: Wait for Caddy to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_caddy
  register: caddy_health
  changed_when: false
  retries: 15
  delay: 10
  until: caddy_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show Caddy logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_caddy --tail 30"
  become: true
  changed_when: false
  when: caddy_health.stdout | default('') != 'healthy'

# Caddy unhealthy is non-blocking (recovers when backends come up)
- name: Warn if Caddy is unhealthy (non-blocking)
  ansible.builtin.debug:
    msg: "WARNING: Caddy not yet healthy. Will recover when backends are up."
  when: caddy_health.stdout | default('') != 'healthy'

- name: Display Phase A health summary
  ansible.builtin.debug:
    msg: >-
      Phase A:
      PG={{ pg_health.stdout | default('?') }}
      Redis={{ redis_health.stdout | default('?') }}
      Qdrant={{ qdrant_health.stdout | default('?') }}
      Caddy={{ caddy_health.stdout | default('?') }}

# === PHASE B : APPLICATIONS ===
- name: Deploy docker-compose.yml template (apps + monitoring)
  ansible.builtin.template:
    src: docker-compose.yml.j2
    dest: "/opt/{{ project_name }}/docker-compose.yml"
    owner: "{{ prod_user }}"
    group: "{{ prod_user }}"
    mode: "0644"
  become: true
  notify: Restart docker stack

- name: Start Applications stack (Phase B)
  community.docker.docker_compose_v2:
    project_src: "/opt/{{ project_name }}"
    files:
      - docker-compose.yml
    state: present
  become: true
  register: docker_apps_result
  failed_when: false

- name: Display Applications stack status
  ansible.builtin.debug:
    msg: |
      {% if docker_apps_result.failed | default(false) %}
      Phase B errors: {{ docker_apps_result.msg | default('unknown') }}
      {% else %}
      Phase B deployed successfully
      {% endif %}

# Restart LiteLLM to ensure it connects to the provisioned database
# REX: LiteLLM may be in error state if it started before DB was provisioned
- name: Check LiteLLM container health
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_litellm
  register: litellm_precheck
  changed_when: false
  failed_when: false
  become: true

- name: Restart LiteLLM if not healthy
  ansible.builtin.command:
    cmd: "docker restart {{ project_name }}_litellm"
  become: true
  changed_when: true
  when: litellm_precheck.stdout | default('') != 'healthy'

- name: Wait for LiteLLM to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_litellm
  register: litellm_health
  changed_when: false
  retries: 20
  delay: 10
  until: litellm_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show LiteLLM logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_litellm --tail 30"
  become: true
  changed_when: false
  when: litellm_health.stdout | default('') != 'healthy'

- name: Warn if LiteLLM is unhealthy
  ansible.builtin.debug:
    msg: "WARNING: LiteLLM not yet healthy after restart. Check logs above."
  when: litellm_health.stdout | default('') != 'healthy'

# === FINAL STATUS ===
- name: List all running containers
  ansible.builtin.command:
    cmd: >-
      docker ps --format
      'table {{ '{{' }}.Names{{ '}}' }}\t{{ '{{' }}.Status{{ '}}' }}'
  register: docker_ps_output
  changed_when: false
  become: true

- name: Display final container status
  ansible.builtin.debug:
    msg: "{{ docker_ps_output.stdout_lines }}"
