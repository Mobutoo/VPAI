#!/bin/bash
# {{ ansible_managed }}
# Smoke tests for {{ project_display_name }}
# Usage: {{ smoke_test_script_path }}
# Exit code: 0 = all tests passed, 1 = at least one test failed

set -euo pipefail

BASE_URL="{{ smoke_test_base_url }}"
OPENCLAW_URL="https://{{ admin_subdomain | default('admin') }}.{{ domain_name }}"
{% if grafana_subdomain | default('') | length > 0 %}
GRAFANA_URL="https://{{ grafana_subdomain }}.{{ domain_name }}"
{% else %}
GRAFANA_URL="${OPENCLAW_URL}/grafana"
{% endif %}
{% if n8n_subdomain | default('') | length > 0 %}
N8N_URL="https://{{ n8n_subdomain }}.{{ domain_name }}"
{% else %}
N8N_URL="${OPENCLAW_URL}/n8n"
{% endif %}
{% if litellm_subdomain | default('') | length > 0 %}
LITELLM_URL="https://{{ litellm_subdomain }}.{{ domain_name }}"
{% else %}
LITELLM_URL="${BASE_URL}/litellm"
{% endif %}
{% if qdrant_subdomain | default('') | length > 0 %}
QDRANT_URL="https://{{ qdrant_subdomain }}.{{ domain_name }}"
{% else %}
QDRANT_URL="${OPENCLAW_URL}/qdrant"
{% endif %}
TIMEOUT="{{ smoke_test_timeout }}"
PROJECT="{{ project_name }}"
FAILURES=0

# VPN-protected services: resolve domains via Tailscale IP
# so Caddy sees a VPN source IP (in {{ caddy_vpn_cidr }}) instead of Docker gateway IP
TAILSCALE_IP=$(tailscale ip -4 2>/dev/null || echo "")
CURL_VPN_OPTS=""
if [ -n "${TAILSCALE_IP}" ]; then
  CURL_VPN_OPTS="--resolve {{ admin_subdomain | default('admin') }}.{{ domain_name }}:443:${TAILSCALE_IP}"
{% if grafana_subdomain | default('') | length > 0 %}
  CURL_VPN_OPTS="${CURL_VPN_OPTS} --resolve {{ grafana_subdomain }}.{{ domain_name }}:443:${TAILSCALE_IP}"
{% endif %}
{% if n8n_subdomain | default('') | length > 0 %}
  CURL_VPN_OPTS="${CURL_VPN_OPTS} --resolve {{ n8n_subdomain }}.{{ domain_name }}:443:${TAILSCALE_IP}"
{% endif %}
{% if litellm_subdomain | default('') | length > 0 %}
  CURL_VPN_OPTS="${CURL_VPN_OPTS} --resolve {{ litellm_subdomain }}.{{ domain_name }}:443:${TAILSCALE_IP}"
{% endif %}
{% if qdrant_subdomain | default('') | length > 0 %}
  CURL_VPN_OPTS="${CURL_VPN_OPTS} --resolve {{ qdrant_subdomain }}.{{ domain_name }}:443:${TAILSCALE_IP}"
{% endif %}
{% if kaneo_subdomain_override | default('') | length > 0 %}
  CURL_VPN_OPTS="${CURL_VPN_OPTS} --resolve {{ kaneo_subdomain_override }}.{{ domain_name }}:443:${TAILSCALE_IP}"
{% endif %}
  echo "INFO  Using Tailscale IP ${TAILSCALE_IP} for VPN-protected endpoints"
else
  echo "WARN  Tailscale not available — VPN-protected endpoint tests may fail"
fi

check_http() {
  local name="$1" url="$2" expected="${3:-200}"
  local status
  # shellcheck disable=SC2086
  status=$(curl -sL -o /dev/null -w "%{http_code}" --max-time "${TIMEOUT}" ${CURL_VPN_OPTS} "$url" 2>/dev/null) || status="000"
  if [ "$status" = "$expected" ]; then
    echo "PASS  $name (HTTP $status)"
  else
    echo "FAIL  $name (HTTP $status, expected $expected)"
    FAILURES=$((FAILURES + 1))
  fi
}

check_container() {
  local name="$1" container="$2"
  local state
  state=$(docker inspect --format='{{ '{{' }}.State.Status{{ '}}' }}' "${PROJECT}_${container}" 2>/dev/null) || state="not_found"
  if [ "$state" = "running" ]; then
    echo "PASS  $name container (running)"
  else
    echo "FAIL  $name container (state: $state)"
    FAILURES=$((FAILURES + 1))
  fi
}

check_container_health() {
  local name="$1" container="$2"
  local health
  health=$(docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}' "${PROJECT}_${container}" 2>/dev/null) || health="unknown"
  if [ "$health" = "healthy" ]; then
    echo "PASS  $name healthcheck (healthy)"
  else
    echo "FAIL  $name healthcheck ($health)"
    FAILURES=$((FAILURES + 1))
  fi
}

echo "============================================"
echo "  Smoke Tests - {{ project_display_name }}"
echo "  $(date)"
echo "  Target: ${BASE_URL}"
echo "============================================"
echo ""

# === HTTPS & TLS ===
echo "--- HTTPS & TLS ---"
check_http "Caddy HTTPS health" "${BASE_URL}/health"

# Check TLS certificate validity
TLS_EXPIRY=$(echo | openssl s_client -servername "{{ domain_name }}" -connect "{{ domain_name }}:443" 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2) || TLS_EXPIRY=""
if [ -n "${TLS_EXPIRY}" ]; then
  EXPIRY_EPOCH=$(date -d "${TLS_EXPIRY}" +%s 2>/dev/null) || EXPIRY_EPOCH=0
  NOW_EPOCH=$(date +%s)
  DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))
  if [ "${DAYS_LEFT}" -gt 7 ]; then
    echo "PASS  TLS certificate (expires in ${DAYS_LEFT} days)"
  else
    echo "FAIL  TLS certificate (expires in ${DAYS_LEFT} days)"
    FAILURES=$((FAILURES + 1))
  fi
else
  echo "FAIL  TLS certificate (could not check)"
  FAILURES=$((FAILURES + 1))
fi

# Check DNS resolution (use getent — available everywhere, dig may not be installed)
DNS_RESULT=$(getent hosts "{{ domain_name }}" 2>/dev/null | awk '{print $1}' | head -1) || DNS_RESULT=""
if [ -n "${DNS_RESULT}" ]; then
  echo "PASS  DNS resolution ({{ domain_name }} -> ${DNS_RESULT})"
else
  echo "FAIL  DNS resolution ({{ domain_name }} not resolving)"
  FAILURES=$((FAILURES + 1))
fi

echo ""

{% if caddy_webhook_relay | default(false) | bool or caddy_vpn_only_mode | default(false) | bool %}
# === WEBHOOK RELAY ===
echo "--- Webhook Relay (Seko-VPN) ---"
RELAY_URL="https://{{ webhook_subdomain | default('hook') }}.{{ domain_name }}"
RELAY_STATUS=$(curl -sL -o /dev/null -w "%{http_code}" --max-time "${TIMEOUT}" "${RELAY_URL}/health" 2>/dev/null) || RELAY_STATUS="000"
if [ "$RELAY_STATUS" = "200" ]; then
  echo "PASS  Webhook relay health (HTTP $RELAY_STATUS)"
else
  echo "FAIL  Webhook relay health (HTTP $RELAY_STATUS, expected 200)"
  FAILURES=$((FAILURES + 1))
fi

# Test relay forwards to n8n (expect 404 from n8n = path exists but no active workflow)
{% for path in caddy_public_webhook_paths | default([]) %}
RELAY_WH_STATUS=$(curl -sL -o /dev/null -w "%{http_code}" --max-time "${TIMEOUT}" "${RELAY_URL}{{ path }}" 2>/dev/null) || RELAY_WH_STATUS="000"
if [ "$RELAY_WH_STATUS" != "000" ]; then
  echo "PASS  Webhook relay {{ path }} reachable (HTTP $RELAY_WH_STATUS)"
else
  echo "FAIL  Webhook relay {{ path }} unreachable"
  FAILURES=$((FAILURES + 1))
fi
{% endfor %}

echo ""
{% endif %}

# === APPLICATION HEALTH ===
echo "--- Application Endpoints ---"
check_http "n8n healthz" "${N8N_URL}/healthz"
check_http "Grafana health" "${GRAFANA_URL}/api/health"
{% if kaneo_subdomain_override | default('') | length > 0 %}
# shellcheck disable=SC2086
KANEO_URL="https://{{ kaneo_subdomain_override }}.{{ domain_name }}"
check_http "Kaneo API health" "${KANEO_URL}/api/health"
{% endif %}
# LiteLLM /health requires auth (master_key in general_settings)
# shellcheck disable=SC2086
LITELLM_STATUS=$(curl -sL -o /dev/null -w "%{http_code}" --max-time "${TIMEOUT}" \
  -H "Authorization: Bearer {{ litellm_master_key }}" \
  ${CURL_VPN_OPTS} "${LITELLM_URL}/health" 2>/dev/null) || LITELLM_STATUS="000"
if [ "$LITELLM_STATUS" = "200" ]; then
  echo "PASS  LiteLLM health (HTTP $LITELLM_STATUS)"
else
  echo "FAIL  LiteLLM health (HTTP $LITELLM_STATUS, expected 200)"
  FAILURES=$((FAILURES + 1))
fi

echo ""

# === CONTAINER STATUS ===
echo "--- Container Status ---"
check_container "PostgreSQL" "postgresql"
check_container "Redis" "redis"
check_container "Qdrant" "qdrant"
check_container "n8n" "n8n"
check_container "LiteLLM" "litellm"
check_container "OpenClaw" "openclaw"
check_container "Caddy" "caddy"
check_container "VictoriaMetrics" "victoriametrics"
check_container "Loki" "loki"
check_container "Alloy" "alloy"
check_container "Grafana" "grafana"
check_container "DIUN" "diun"
check_container "Kaneo API" "kaneo_api"
check_container "Kaneo Web" "kaneo_web"

echo ""

# === CONTAINER HEALTHCHECKS ===
echo "--- Container Health ---"
check_container_health "PostgreSQL" "postgresql"
check_container_health "Redis" "redis"
check_container_health "Qdrant" "qdrant"
check_container_health "n8n" "n8n"
check_container_health "LiteLLM" "litellm"
check_container_health "Caddy" "caddy"
check_container_health "VictoriaMetrics" "victoriametrics"
check_container_health "Loki" "loki"
check_container_health "Grafana" "grafana"
check_container_health "Kaneo API" "kaneo_api"

echo ""

# === DATABASE CONNECTIVITY ===
echo "--- Database Connectivity ---"

# PostgreSQL
PG_READY=$(docker exec "${PROJECT}_postgresql" pg_isready -U postgres 2>/dev/null) && PG_RC=0 || PG_RC=1
if [ "${PG_RC}" -eq 0 ]; then
  echo "PASS  PostgreSQL connectivity (pg_isready)"
else
  echo "FAIL  PostgreSQL connectivity"
  FAILURES=$((FAILURES + 1))
fi

# Redis
REDIS_PING=$(docker exec "${PROJECT}_redis" redis-cli -a "{{ redis_password }}" ping 2>/dev/null) || REDIS_PING=""
if [ "${REDIS_PING}" = "PONG" ]; then
  echo "PASS  Redis connectivity (PONG)"
else
  echo "FAIL  Redis connectivity (got: ${REDIS_PING})"
  FAILURES=$((FAILURES + 1))
fi

# Qdrant
QDRANT_HEALTH=$(docker exec "${PROJECT}_qdrant" bash -c ':> /dev/tcp/localhost/6333' 2>/dev/null) && QDRANT_RC=0 || QDRANT_RC=1
if [ "${QDRANT_RC}" -eq 0 ]; then
  echo "PASS  Qdrant connectivity"
else
  echo "FAIL  Qdrant connectivity"
  FAILURES=$((FAILURES + 1))
fi

echo ""

# === LiteLLM API ===
echo "--- LiteLLM API ---"
# shellcheck disable=SC2086
MODELS=$(curl -s -H "Authorization: Bearer {{ litellm_master_key }}" \
  ${CURL_VPN_OPTS} "${LITELLM_URL}/v1/models" --max-time "${TIMEOUT}" 2>/dev/null | \
  grep -o '"id"' | wc -l) || MODELS=0
if [ "${MODELS}" -ge 8 ]; then
  echo "PASS  LiteLLM models (${MODELS} models available, expected >= 8)"
elif [ "${MODELS}" -gt 0 ]; then
  echo "WARN  LiteLLM models (${MODELS} available, expected >= 8 — some providers may not be configured)"
else
  echo "FAIL  LiteLLM models (no models found)"
  FAILURES=$((FAILURES + 1))
fi

echo ""

# === QDRANT COLLECTIONS ===
echo "--- Qdrant Collections ---"
# Check semantic_cache collection exists
QDRANT_IP=$(docker inspect -f '{{ '{{' }}range .NetworkSettings.Networks{{ '}}' }}{{ '{{' }}.IPAddress{{ '}}' }}{{ '{{' }}end{{ '}}' }}' "${PROJECT}_qdrant" 2>/dev/null | head -c -1) || QDRANT_IP=""
if [ -n "${QDRANT_IP}" ]; then
  SC_STATUS=$(curl -s --max-time 5 -H "api-key: {{ qdrant_api_key }}" \
    "http://${QDRANT_IP}:6333/collections/{{ qdrant_cache_collection }}" 2>/dev/null | \
    grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4) || SC_STATUS=""
  if [ "${SC_STATUS}" = "green" ] || [ -n "${SC_STATUS}" ]; then
    echo "PASS  Qdrant {{ qdrant_cache_collection }} collection (${SC_STATUS:-exists})"
  else
    echo "WARN  Qdrant {{ qdrant_cache_collection }} collection not found (created on first LiteLLM cache write)"
  fi

  CI_STATUS=$(curl -s --max-time 5 -H "api-key: {{ qdrant_api_key }}" \
    "http://${QDRANT_IP}:6333/collections/{{ qdrant_rag_collection }}" 2>/dev/null | \
    grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4) || CI_STATUS=""
  if [ "${CI_STATUS}" = "green" ] || [ -n "${CI_STATUS}" ]; then
    echo "PASS  Qdrant {{ qdrant_rag_collection }} collection (${CI_STATUS:-exists})"
  else
    echo "WARN  Qdrant {{ qdrant_rag_collection }} collection not found (created on first RAG indexation)"
  fi
else
  echo "SKIP  Qdrant collections (could not get container IP)"
fi

echo ""

{% if openclaw_volume_isolation | default(false) %}
# === VOLUME ISOLATION ===
echo "--- OpenClaw Volume Isolation ---"
# Test agents directory is persistent (mounted as volume)
AGENT_DIR=$(docker exec "${PROJECT}_openclaw" ls /home/node/.openclaw/agents/concierge/IDENTITY.md 2>&1) && AGENT_OK=1 || AGENT_OK=0
if [ "${AGENT_OK}" -eq 1 ]; then
  echo "PASS  OpenClaw agents directory mounted (concierge/IDENTITY.md exists)"
else
  echo "WARN  OpenClaw agents/concierge/IDENTITY.md not found"
fi

# Test workspace is writable
TOUCH_WS=$(docker exec "${PROJECT}_openclaw" touch /home/node/.openclaw/workspace/test_rw 2>&1) && WS_OK=1 || WS_OK=0
if [ "${WS_OK}" -eq 1 ]; then
  docker exec "${PROJECT}_openclaw" rm -f /home/node/.openclaw/workspace/test_rw 2>/dev/null || true
  echo "PASS  OpenClaw workspace directory is writable"
else
  echo "FAIL  OpenClaw workspace directory is not writable"
  FAILURES=$((FAILURES + 1))
fi

echo ""
{% endif %}

# === SERVICE PROVISIONING ===
echo "--- Service Provisioning ---"

# n8n owner provisioned (check if setup page is gone)
# shellcheck disable=SC2086
N8N_SETTINGS=$(curl -s ${CURL_VPN_OPTS} "${N8N_URL}/rest/settings" --max-time "${TIMEOUT}" 2>/dev/null || echo '{}')
N8N_SETUP_PAGE=$(echo "$N8N_SETTINGS" | grep -o '"showSetupPage":[a-z]*' | cut -d: -f2 || echo "unknown")
if [ "$N8N_SETUP_PAGE" = "false" ]; then
  echo "PASS  n8n owner provisioned (setup complete)"
elif [ "$N8N_SETUP_PAGE" = "true" ]; then
  echo "WARN  n8n owner NOT provisioned (setup page still showing)"
else
  echo "SKIP  n8n owner check (could not determine setup state)"
fi

# LiteLLM UI accessible (on dedicated subdomain)
check_http "LiteLLM UI" "${LITELLM_URL}/ui/" "200"

# Grafana login possible (dedicated subdomain)
check_http "Grafana login page" "${GRAFANA_URL}/login" "200"

echo ""

# === RESULTS ===
echo "============================================"
if [ "${FAILURES}" -eq 0 ]; then
  echo "  ALL TESTS PASSED"
  echo "============================================"
  exit 0
else
  echo "  ${FAILURES} TEST(S) FAILED"
  echo "============================================"
  exit 1
fi
