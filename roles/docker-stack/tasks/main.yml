---
# docker-stack — tasks
# Deploie la stack Docker en phases isolees avec healthchecks individuels
# Chaque service est verifie separement pour faciliter le troubleshooting

- name: Create project directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ prod_user }}"
    group: "{{ prod_user }}"
    mode: "0755"
  loop:
    - "/opt/{{ project_name }}"
    - "/opt/{{ project_name }}/logs/caddy"
    - "/opt/{{ project_name }}/scripts"
  become: true

# === CLEANUP : Stop Phase B apps before redeploy (infra stays running) ===
- name: Stop Phase B apps stack if it exists
  ansible.builtin.shell:
    executable: /bin/bash
    cmd: |
      set -o pipefail
      cd /opt/{{ project_name }}
      if [ -f docker-compose.yml ]; then
        docker compose -f docker-compose.yml down --remove-orphans 2>/dev/null || true
      fi
  become: true
  changed_when: false
  failed_when: false

# === PHASE A : INFRASTRUCTURE (all services start independently) ===
- name: Deploy docker-compose-infra.yml template
  ansible.builtin.template:
    src: docker-compose-infra.yml.j2
    dest: "/opt/{{ project_name }}/docker-compose-infra.yml"
    owner: "{{ prod_user }}"
    group: "{{ prod_user }}"
    mode: "0644"
  become: true

- name: Start Infrastructure stack (Phase A)
  community.docker.docker_compose_v2:
    project_src: "/opt/{{ project_name }}"
    files:
      - docker-compose-infra.yml
    state: present
  become: true
  register: docker_infra_result
  failed_when: false

- name: Show Phase A errors if any
  ansible.builtin.debug:
    msg: >-
      Phase A returned: {{ docker_infra_result.msg | default('OK') }}
  when: docker_infra_result.failed | default(false)

# === INDIVIDUAL HEALTH CHECKS (with diagnostic logs on failure) ===

# --- PostgreSQL ---
- name: Wait for PostgreSQL to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_postgresql
  register: pg_health
  changed_when: false
  retries: 20
  delay: 5
  until: pg_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show PostgreSQL logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_postgresql --tail 30"
  become: true
  changed_when: false
  when: pg_health.stdout | default('') != 'healthy'

- name: Fail if PostgreSQL is unhealthy
  ansible.builtin.fail:
    msg: "PostgreSQL failed to become healthy. Check logs above."
  when: pg_health.stdout | default('') != 'healthy'

# --- PostgreSQL provisioning (idempotent — creates DBs/users if missing) ---
# REX: init.sql only runs on FIRST PostgreSQL initialization (empty data dir)
# Subsequent deploys need explicit provisioning for new databases/users
- name: Deploy PostgreSQL provisioning script
  ansible.builtin.template:
    src: provision-postgresql.sh.j2
    dest: "/opt/{{ project_name }}/scripts/provision-postgresql.sh"
    owner: "{{ prod_user }}"
    group: "{{ prod_user }}"
    mode: "0750"
  become: true

- name: Provision PostgreSQL databases and users
  ansible.builtin.command:
    cmd: "/opt/{{ project_name }}/scripts/provision-postgresql.sh"
  become: true
  register: pg_provision
  changed_when: "'Creating' in pg_provision.stdout"

- name: Show PostgreSQL provisioning output
  ansible.builtin.debug:
    msg: "{{ pg_provision.stdout_lines }}"
  when: pg_provision.stdout_lines | default([]) | length > 0

# --- Redis ---
- name: Wait for Redis to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_redis
  register: redis_health
  changed_when: false
  retries: 10
  delay: 3
  until: redis_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show Redis logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_redis --tail 30"
  become: true
  changed_when: false
  when: redis_health.stdout | default('') != 'healthy'

- name: Fail if Redis is unhealthy
  ansible.builtin.fail:
    msg: "Redis failed to become healthy. Check logs above."
  when: redis_health.stdout | default('') != 'healthy'

# --- Qdrant ---
- name: Wait for Qdrant to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_qdrant
  register: qdrant_health
  changed_when: false
  retries: 10
  delay: 3
  until: qdrant_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show Qdrant logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_qdrant --tail 30"
  become: true
  changed_when: false
  when: qdrant_health.stdout | default('') != 'healthy'

- name: Fail if Qdrant is unhealthy
  ansible.builtin.fail:
    msg: "Qdrant failed to become healthy. Check logs above."
  when: qdrant_health.stdout | default('') != 'healthy'

# --- Qdrant Collection Provisioning (idempotent) ---
# Creates collections needed by LiteLLM semantic cache and RAG indexing
# REX: Qdrant image has no curl/wget — use docker exec + bash /dev/tcp
- name: Provision Qdrant semantic_cache collection
  ansible.builtin.shell:
    executable: /bin/bash
    cmd: |
      set -euo pipefail
      CONTAINER="{{ project_name }}_qdrant"
      COLLECTION="{{ qdrant_cache_collection }}"
      API_KEY="{{ qdrant_api_key }}"

      # Check if collection exists
      EXISTS=$(docker exec "${CONTAINER}" bash -c \
        "exec 3<>/dev/tcp/localhost/6333; \
         printf 'GET /collections/${COLLECTION} HTTP/1.1\r\nHost: localhost\r\napi-key: ${API_KEY}\r\n\r\n' >&3; \
         timeout 5 cat <&3" 2>/dev/null | head -1 || echo "")

      if echo "${EXISTS}" | grep -q "200 OK"; then
        echo "EXISTS"
      else
        # Create collection with cosine distance
        DIMS="{{ qdrant_embedding_dimensions }}"
        BODY="{\"vectors\":{\"size\":${DIMS},\"distance\":\"Cosine\"}}"
        LEN=$(echo -n "${BODY}" | wc -c)
        HDR="PUT /collections/${COLLECTION} HTTP/1.1\r\n"
        HDR="${HDR}Host: localhost\r\napi-key: ${API_KEY}\r\n"
        HDR="${HDR}Content-Type: application/json\r\n"
        HDR="${HDR}Content-Length: ${LEN}\r\n\r\n"
        docker exec "${CONTAINER}" bash -c \
          "exec 3<>/dev/tcp/localhost/6333; \
           printf '${HDR}${BODY}' >&3; \
           timeout 5 cat <&3"
        echo "CREATED"
      fi
  become: true
  register: qdrant_cache_provision
  changed_when: "'CREATED' in qdrant_cache_provision.stdout"
  failed_when: false
  no_log: true

- name: Show Qdrant semantic_cache provisioning result
  ansible.builtin.debug:
    msg: "Qdrant {{ qdrant_cache_collection }}: {{ qdrant_cache_provision.stdout_lines | default(['unknown']) | last }}"

- name: Provision Qdrant content_index collection (RAG)
  ansible.builtin.shell:
    executable: /bin/bash
    cmd: |
      set -euo pipefail
      CONTAINER="{{ project_name }}_qdrant"
      COLLECTION="{{ qdrant_rag_collection }}"
      API_KEY="{{ qdrant_api_key }}"

      # Check if collection exists
      EXISTS=$(docker exec "${CONTAINER}" bash -c \
        "exec 3<>/dev/tcp/localhost/6333; \
         printf 'GET /collections/${COLLECTION} HTTP/1.1\r\nHost: localhost\r\napi-key: ${API_KEY}\r\n\r\n' >&3; \
         timeout 5 cat <&3" 2>/dev/null | head -1 || echo "")

      if echo "${EXISTS}" | grep -q "200 OK"; then
        echo "EXISTS"
      else
        # Create collection with cosine distance + indexing config
        DIMS="{{ qdrant_embedding_dimensions }}"
        BODY="{\"vectors\":{\"size\":${DIMS},"
        BODY="${BODY}\"distance\":\"Cosine\"},"
        BODY="${BODY}\"optimizers_config\":"
        BODY="${BODY}{\"indexing_threshold\":10000}}"
        LEN=$(echo -n "${BODY}" | wc -c)
        HDR="PUT /collections/${COLLECTION} HTTP/1.1\r\n"
        HDR="${HDR}Host: localhost\r\napi-key: ${API_KEY}\r\n"
        HDR="${HDR}Content-Type: application/json\r\n"
        HDR="${HDR}Content-Length: ${LEN}\r\n\r\n"
        docker exec "${CONTAINER}" bash -c \
          "exec 3<>/dev/tcp/localhost/6333; \
           printf '${HDR}${BODY}' >&3; \
           timeout 5 cat <&3"
        echo "CREATED"
      fi
  become: true
  register: qdrant_rag_provision
  changed_when: "'CREATED' in qdrant_rag_provision.stdout"
  failed_when: false
  no_log: true

- name: Show Qdrant content_index provisioning result
  ansible.builtin.debug:
    msg: "Qdrant {{ qdrant_rag_collection }}: {{ qdrant_rag_provision.stdout_lines | default(['unknown']) | last }}"

# --- Caddy ---
- name: Wait for Caddy to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_caddy
  register: caddy_health
  changed_when: false
  retries: 15
  delay: 10
  until: caddy_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show Caddy logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_caddy --tail 30"
  become: true
  changed_when: false
  when: caddy_health.stdout | default('') != 'healthy'

# Caddy unhealthy is non-blocking (recovers when backends come up)
- name: Warn if Caddy is unhealthy (non-blocking)
  ansible.builtin.debug:
    msg: "WARNING: Caddy not yet healthy. Will recover when backends are up."
  when: caddy_health.stdout | default('') != 'healthy'

- name: Display Phase A health summary
  ansible.builtin.debug:
    msg: >-
      Phase A:
      PG={{ pg_health.stdout | default('?') }}
      Redis={{ redis_health.stdout | default('?') }}
      Qdrant={{ qdrant_health.stdout | default('?') }}
      Caddy={{ caddy_health.stdout | default('?') }}

# === PHASE B : APPLICATIONS ===
- name: Deploy docker-compose.yml template (apps + monitoring)
  ansible.builtin.template:
    src: docker-compose.yml.j2
    dest: "/opt/{{ project_name }}/docker-compose.yml"
    owner: "{{ prod_user }}"
    group: "{{ prod_user }}"
    mode: "0644"
  become: true
  notify: Restart docker stack

- name: Start Applications stack (Phase B)
  community.docker.docker_compose_v2:
    project_src: "/opt/{{ project_name }}"
    files:
      - docker-compose.yml
    state: present
  become: true
  register: docker_apps_result
  failed_when: false

- name: Display Applications stack status
  ansible.builtin.debug:
    msg: |
      {% if docker_apps_result.failed | default(false) %}
      Phase B errors: {{ docker_apps_result.msg | default('unknown') }}
      {% else %}
      Phase B deployed successfully
      {% endif %}

# Restart LiteLLM to ensure it connects to the provisioned database
# REX: LiteLLM may be in error state if it started before DB was provisioned
- name: Check LiteLLM container health
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_litellm
  register: litellm_precheck
  changed_when: false
  failed_when: false
  become: true

- name: Restart LiteLLM if not healthy
  ansible.builtin.command:
    cmd: "docker restart {{ project_name }}_litellm"
  become: true
  changed_when: true
  failed_when: false
  register: litellm_restart
  when: litellm_precheck.stdout | default('') != 'healthy'

- name: Show LiteLLM restart result
  ansible.builtin.debug:
    msg: >-
      LiteLLM restart: {{ litellm_restart.rc | default('skipped') }}
      {{ litellm_restart.stderr | default('') }}
  when: litellm_restart is not skipped and litellm_restart.rc | default(0) != 0

- name: Wait for LiteLLM to be healthy
  ansible.builtin.command:
    cmd: >-
      docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}'
      {{ project_name }}_litellm
  register: litellm_health
  changed_when: false
  retries: 20
  delay: 10
  until: litellm_health.stdout | default('') == 'healthy'
  become: true
  failed_when: false

- name: Show LiteLLM logs if unhealthy
  ansible.builtin.command:
    cmd: "docker logs {{ project_name }}_litellm --tail 30"
  become: true
  changed_when: false
  failed_when: false
  when: litellm_health.stdout | default('') != 'healthy'

- name: Warn if LiteLLM is unhealthy
  ansible.builtin.debug:
    msg: "WARNING: LiteLLM not yet healthy after restart. Check logs above."
  when: litellm_health.stdout | default('') != 'healthy'

# === FINAL STATUS ===
- name: List all running containers
  ansible.builtin.command:
    cmd: >-
      docker ps --format
      'table {{ '{{' }}.Names{{ '}}' }}\t{{ '{{' }}.Status{{ '}}' }}'
  register: docker_ps_output
  changed_when: false
  become: true

- name: Display final container status
  ansible.builtin.debug:
    msg: "{{ docker_ps_output.stdout_lines }}"
