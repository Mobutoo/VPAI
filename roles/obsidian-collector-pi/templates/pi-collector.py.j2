#!/usr/bin/env python3
"""
roles/obsidian-collector-pi/templates/pi-collector.py.j2
Collecteurs Raspberry Pi → CouchDB Obsidian LiveSync

Collecte (cron 04:00 quotidien) :
  - ComfyUI output images → Pi/ComfyUI/Renders/YYYY-MM-DD.md
  - Remotion output videos → Pi/Remotion/Renders/YYYY-MM-DD.md
"""
import base64
import glob
import json
import os
import sys
import time
import urllib.request
import urllib.error
from datetime import datetime, timezone
from pathlib import Path

# === Configuration (générée par Ansible) ===
COUCHDB_URL = "{{ obsidian_pi_couchdb_url }}"
DB = "{{ obsidian_pi_couchdb_db }}"
AUTH = ("{{ obsidian_pi_couchdb_user }}", "{{ obsidian_pi_couchdb_password }}")

COMFYUI_OUTPUT = "{{ obsidian_pi_comfyui_output }}"
REMOTION_OUTPUT = "{{ obsidian_pi_remotion_output }}"

# Période incrémentale : fichiers des 25 dernières heures
INCREMENTAL_HOURS = 25


# === Utilitaires CouchDB / LiveSync ===

def livesync_id(path: str) -> str:
    return "v2:plain:" + base64.b64encode(path.encode()).decode()


def couch_request(method: str, path: str, data: dict | None = None) -> tuple[int, dict]:
    url = f"{COUCHDB_URL}/{path}"
    body = json.dumps(data).encode() if data else None
    creds = base64.b64encode(f"{AUTH[0]}:{AUTH[1]}".encode()).decode()
    req = urllib.request.Request(url, data=body, method=method)
    req.add_header("Authorization", f"Basic {creds}")
    req.add_header("Content-Type", "application/json")
    try:
        with urllib.request.urlopen(req) as resp:
            return resp.status, json.loads(resp.read())
    except urllib.error.HTTPError as e:
        return e.code, json.loads(e.read())


def push_note(vault_path: str, content: str) -> bool:
    doc_id = livesync_id(vault_path)
    now_ms = int(time.time() * 1000)
    status, existing = couch_request("GET", f"{DB}/{doc_id}")
    rev = existing.get("_rev") if status == 200 else None
    doc = {
        "_id": doc_id,
        "data": content,
        "datatype": "plain",
        "mtime": now_ms,
        "ctime": existing.get("ctime", now_ms) if rev else now_ms,
        "type": "leaf",
    }
    if rev:
        doc["_rev"] = rev
    status, _ = couch_request("PUT", f"{DB}/{doc_id}", doc)
    return status in (200, 201)


def is_recent(filepath: str) -> bool:
    try:
        mtime = os.path.getmtime(filepath)
        age_hours = (time.time() - mtime) / 3600
        return age_hours <= INCREMENTAL_HOURS
    except OSError:
        return False


def get_date_str(filepath: str) -> str:
    try:
        mtime = os.path.getmtime(filepath)
        return datetime.fromtimestamp(mtime, tz=timezone.utc).strftime("%Y-%m-%d")
    except OSError:
        return datetime.now(tz=timezone.utc).strftime("%Y-%m-%d")


# === Collectors ===

def collect_comfyui_renders() -> int:
    """Log des images ComfyUI générées → Pi/ComfyUI/Renders/YYYY-MM-DD.md"""
    if not os.path.exists(COMFYUI_OUTPUT):
        return 0

    # Grouper les nouveaux fichiers par date
    renders_by_date: dict[str, list[dict]] = {}
    for ext in ("*.png", "*.jpg", "*.webp"):
        for filepath in glob.glob(os.path.join(COMFYUI_OUTPUT, ext)):
            if not is_recent(filepath):
                continue
            date_str = get_date_str(filepath)
            fname = os.path.basename(filepath)
            size_kb = os.path.getsize(filepath) // 1024

            # Chercher le fichier JSON compagnon (ComfyUI génère <filename>.json)
            json_path = filepath.rsplit(".", 1)[0] + ".json"
            prompt = ""
            if os.path.exists(json_path):
                try:
                    with open(json_path, encoding="utf-8") as f:
                        meta = json.load(f)
                    # ComfyUI stocke le prompt dans différents formats selon la version
                    prompt = str(meta).get("prompt", "")[:200] if isinstance(meta, dict) else ""
                except (json.JSONDecodeError, OSError):
                    pass

            renders_by_date.setdefault(date_str, []).append({
                "file": fname,
                "size_kb": size_kb,
                "prompt": prompt,
                "ts": datetime.fromtimestamp(
                    os.path.getmtime(filepath), tz=timezone.utc
                ).strftime("%H:%M"),
            })

    pushed = 0
    for date_str, renders in renders_by_date.items():
        vault_path = f"Pi/ComfyUI/Renders/{date_str}.md"

        # Lire le contenu existant si la note existe déjà (append journalier)
        status, existing_doc = couch_request("GET", f"{DB}/{livesync_id(vault_path)}")
        existing_content = existing_doc.get("data", "") if status == 200 else ""

        lines = [
            f"# ComfyUI Renders — {date_str}",
            f"",
            f"*Auto-généré par obsidian-pi-collector*",
            f"",
            f"| Heure | Fichier | Taille | Prompt |",
            f"|---|---|---|---|",
        ]
        for r in sorted(renders, key=lambda x: x["ts"]):
            prompt_preview = r["prompt"][:80].replace("|", "\\|") if r["prompt"] else "—"
            lines.append(f"| {r['ts']} | `{r['file']}` | {r['size_kb']} Ko | {prompt_preview} |")

        content = "\n".join([
            "---",
            f"date: {date_str}",
            "tags: [pi, comfyui, image-generation]",
            "source: auto-generated",
            "---",
            "",
        ] + lines)

        if push_note(vault_path, content):
            pushed += 1

    return pushed


def collect_remotion_renders() -> int:
    """Log des vidéos Remotion rendues → Pi/Remotion/Renders/YYYY-MM-DD.md"""
    if not os.path.exists(REMOTION_OUTPUT):
        return 0

    renders_by_date: dict[str, list[dict]] = {}
    for ext in ("*.mp4", "*.webm", "*.gif"):
        for filepath in glob.glob(os.path.join(REMOTION_OUTPUT, ext)):
            if not is_recent(filepath):
                continue
            date_str = get_date_str(filepath)
            fname = os.path.basename(filepath)
            size_mb = os.path.getsize(filepath) // (1024 * 1024)
            ts = datetime.fromtimestamp(
                os.path.getmtime(filepath), tz=timezone.utc
            ).strftime("%H:%M")
            renders_by_date.setdefault(date_str, []).append({
                "file": fname,
                "size_mb": size_mb,
                "ts": ts,
            })

    pushed = 0
    for date_str, renders in renders_by_date.items():
        vault_path = f"Pi/Remotion/Renders/{date_str}.md"

        lines = [
            f"# Remotion Renders — {date_str}",
            f"",
            f"*Auto-généré par obsidian-pi-collector*",
            f"",
            f"| Heure | Fichier | Taille |",
            f"|---|---|---|",
        ]
        for r in sorted(renders, key=lambda x: x["ts"]):
            lines.append(f"| {r['ts']} | `{r['file']}` | {r['size_mb']} Mo |")

        content = "\n".join([
            "---",
            f"date: {date_str}",
            "tags: [pi, remotion, video]",
            "source: auto-generated",
            "---",
            "",
        ] + lines)

        if push_note(vault_path, content):
            pushed += 1

    return pushed


# === Main ===

def main():
    print(f"[obsidian-pi-collector] Start — {datetime.now().isoformat()}")
    print(f"  CouchDB: {COUCHDB_URL}/{DB}")

    status, _ = couch_request("GET", f"{DB}")
    if status != 200:
        print(f"[obsidian-pi-collector] ERROR: Cannot reach CouchDB ({status})", file=sys.stderr)
        sys.exit(1)

    results = {
        "comfyui": collect_comfyui_renders(),
        "remotion": collect_remotion_renders(),
    }

    total = sum(results.values())
    print(f"[obsidian-pi-collector] Done — {total} notes pushed")
    for k, v in results.items():
        print(f"  {k}: {v}")


if __name__ == "__main__":
    main()
