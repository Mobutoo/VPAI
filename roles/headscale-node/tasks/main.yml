---
# headscale-node — tasks

- name: Create keyrings directory
  ansible.builtin.file:
    path: /etc/apt/keyrings
    state: directory
    mode: "0755"
  become: true

- name: Download Tailscale GPG key
  ansible.builtin.shell:
    executable: /bin/bash
    cmd: |
      set -o pipefail
      DISTRO="{{ ansible_facts['distribution'] | lower }}"
      TAILSCALE_GPG="https://pkgs.tailscale.com/stable/${DISTRO}"
      curl -fsSL "${TAILSCALE_GPG}/{{ ansible_facts['distribution_release'] }}.noarmor.gpg" \
        | gpg --dearmor --yes -o /etc/apt/keyrings/tailscale-archive-keyring.gpg
      chmod a+r /etc/apt/keyrings/tailscale-archive-keyring.gpg
  args:
    creates: /etc/apt/keyrings/tailscale-archive-keyring.gpg
  changed_when: true
  become: true

- name: Add Tailscale repository
  ansible.builtin.apt_repository:
    repo: >-
      deb [signed-by=/etc/apt/keyrings/tailscale-archive-keyring.gpg]
      https://pkgs.tailscale.com/stable/{{ ansible_facts['distribution'] | lower }}
      {{ ansible_facts['distribution_release'] }} main
    state: present
    filename: tailscale
  become: true

- name: Install Tailscale
  ansible.builtin.apt:
    name: tailscale
    state: present
    update_cache: true
  become: true

- name: Enable and start Tailscale service
  ansible.builtin.systemd:
    name: tailscaled
    state: started
    enabled: true
  become: true

- name: Check Tailscale status
  ansible.builtin.command:
    cmd: tailscale status --json
  register: tailscale_status_raw
  changed_when: false
  failed_when: false
  become: true

- name: Parse Tailscale status
  ansible.builtin.set_fact:
    tailscale_status: "{{ tailscale_status_raw.stdout | from_json }}"
  when: tailscale_status_raw.rc == 0

- name: Authenticate with Headscale server
  ansible.builtin.command:
    cmd: >-
      tailscale up
      --login-server={{ headscale_login_server }}
      --authkey={{ headscale_auth_key_value }}
      --hostname={{ headscale_hostname }}
      {% if headscale_accept_routes %}--accept-routes{% endif %}
      {% if headscale_advertise_routes | length > 0 %}--advertise-routes={{ headscale_advertise_routes | join(',') }}{% endif %}
  become: true
  changed_when: true
  no_log: true
  register: tailscale_up_result
  when: >-
    tailscale_status_raw.rc != 0 or
    (tailscale_status is defined and tailscale_status.BackendState != "Running")

- name: Get Tailscale IP address
  ansible.builtin.command:
    cmd: tailscale ip -4
  register: tailscale_ip_result
  changed_when: false
  become: true

- name: Save Tailscale IP as fact
  ansible.builtin.set_fact:
    tailscale_ip: "{{ tailscale_ip_result.stdout | trim }}"
    cacheable: true

- name: Verify VPN connectivity (non-blocking)
  ansible.builtin.command:
    cmd: "ping -c 3 -W 5 {{ headscale_vpn_ip }}"
  changed_when: false
  failed_when: false
  register: vpn_connectivity_check
  become: true

- name: Display VPN connectivity status
  ansible.builtin.debug:
    msg: >-
      {% if vpn_connectivity_check.rc == 0 %}
      ✓ VPN connectivity to Seko-VPN ({{ headscale_vpn_ip }}) is working
      {% else %}
      ⚠ VPN connectivity check failed - VPS will continue using its own routing.
      This is normal on first deployment. Configure routing rules manually if needed.
      {% endif %}

- name: Display Tailscale IP
  ansible.builtin.debug:
    msg: "Tailscale IP assigned: {{ tailscale_ip }}"

# === VPN SPLIT DNS DOCUMENTATION ===
# Admin UIs are VPN-only (Caddy ACL). For web access, VPN clients must
# resolve admin subdomains to the VPS's Tailscale IP so traffic routes
# through the VPN tunnel and Caddy sees a VPN source IP.
- name: Display Split DNS configuration instructions
  ansible.builtin.debug:
    msg: |
      ━━━ VPN SPLIT DNS CONFIGURATION REQUIRED ━━━
      Admin UIs (OpenClaw, Grafana, n8n, LiteLLM, Qdrant) are VPN-only.
      VPN clients must resolve admin domains to the Tailscale IP.

      VPS Tailscale IP: {{ tailscale_ip }}

      OPTION 1 — Headscale config (recommended, affects all VPN clients):
        Edit /etc/headscale/config.yaml on Seko-VPN and add:
          dns:
            magic_dns: true
            base_domain: ts.net
            extra_records:
              - name: "{{ caddy_admin_domain }}"
                type: A
                value: "{{ tailscale_ip }}"
      {% if grafana_subdomain | default('') | length > 0 %}
              - name: "{{ caddy_grafana_domain }}"
                type: A
                value: "{{ tailscale_ip }}"
      {% endif %}
      {% if n8n_subdomain | default('') | length > 0 %}
              - name: "{{ caddy_n8n_domain }}"
                type: A
                value: "{{ tailscale_ip }}"
      {% endif %}
      {% if litellm_subdomain | default('') | length > 0 %}
              - name: "{{ caddy_litellm_domain }}"
                type: A
                value: "{{ tailscale_ip }}"
      {% endif %}
      {% if qdrant_subdomain | default('') | length > 0 %}
              - name: "{{ caddy_qdrant_domain }}"
                type: A
                value: "{{ tailscale_ip }}"
      {% endif %}
        Then restart Headscale: systemctl restart headscale

      OPTION 2 — Client /etc/hosts (per-machine, immediate):
        Add to /etc/hosts (or C:\Windows\System32\drivers\etc\hosts):
          {{ tailscale_ip }}  {{ caddy_admin_domain }}
      {% if grafana_subdomain | default('') | length > 0 %}
          {{ tailscale_ip }}  {{ caddy_grafana_domain }}
      {% endif %}
      {% if n8n_subdomain | default('') | length > 0 %}
          {{ tailscale_ip }}  {{ caddy_n8n_domain }}
      {% endif %}
      {% if litellm_subdomain | default('') | length > 0 %}
          {{ tailscale_ip }}  {{ caddy_litellm_domain }}
      {% endif %}
      {% if qdrant_subdomain | default('') | length > 0 %}
          {{ tailscale_ip }}  {{ caddy_qdrant_domain }}
      {% endif %}
      ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
