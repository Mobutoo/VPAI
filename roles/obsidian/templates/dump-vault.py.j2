#!/usr/bin/env python3
"""
roles/obsidian/templates/dump-vault.py.j2
Dump nightly du vault CouchDB → filesystem pour versioning git.
Décode le format LiveSync v2 (v2:plain:<base64(path)>) → fichiers .md
"""
import base64
import json
import os
import sys
import urllib.request
import urllib.error

COUCHDB_URL = "http://127.0.0.1:{{ couchdb_port }}"
DB = "{{ couchdb_db_name }}"
USER = "{{ couchdb_admin_user }}"
PASS = "{{ couchdb_admin_password }}"
VAULT_DIR = "{{ obsidian_vault_dir }}"


def couch_get(path: str) -> dict:
    url = f"{COUCHDB_URL}/{path}"
    req = urllib.request.Request(url)
    import base64 as b64
    creds = b64.b64encode(f"{USER}:{PASS}".encode()).decode()
    req.add_header("Authorization", f"Basic {creds}")
    with urllib.request.urlopen(req) as resp:
        return json.loads(resp.read())


def decode_path(doc_id: str) -> str | None:
    """Décode un _id LiveSync v2 en chemin relatif.

    Format : v2:plain:<base64(path)>
    """
    if not doc_id.startswith("v2:plain:"):
        return None
    try:
        encoded = doc_id[len("v2:plain:"):]
        path = base64.b64decode(encoded).decode("utf-8")
        # Sécurité : éviter les path traversal
        if ".." in path or path.startswith("/"):
            return None
        return path
    except Exception:
        return None


def main():
    print(f"[dump-vault] Dumping CouchDB vault to {VAULT_DIR}")

    # Récupérer tous les documents
    result = couch_get(f"{DB}/_all_docs?include_docs=true")
    rows = result.get("rows", [])

    written_paths = set()
    written = 0
    skipped = 0

    for row in rows:
        doc = row.get("doc", {})
        doc_id = doc.get("_id", "")

        # Ignorer les documents système CouchDB
        if doc_id.startswith("_"):
            continue

        # Ignorer les documents non-LiveSync
        if doc.get("type") not in ("leaf", "plain"):
            # Accepter aussi les docs sans type (format ancien)
            if "data" not in doc:
                skipped += 1
                continue

        path = decode_path(doc_id)
        if path is None:
            skipped += 1
            continue

        content = doc.get("data", "")
        if not isinstance(content, str):
            skipped += 1
            continue

        # Écrire le fichier
        full_path = os.path.join(VAULT_DIR, path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)

        try:
            with open(full_path, "w", encoding="utf-8") as f:
                f.write(content)
            written_paths.add(full_path)
            written += 1
        except OSError as e:
            print(f"[dump-vault] ERROR writing {full_path}: {e}", file=sys.stderr)

    # Supprimer les fichiers orphelins (absents de CouchDB)
    deleted = 0
    for root, dirs, files in os.walk(VAULT_DIR):
        # Ignorer le répertoire .git
        dirs[:] = [d for d in dirs if d != ".git"]
        for fname in files:
            fpath = os.path.join(root, fname)
            if fpath not in written_paths and fname.endswith(".md"):
                os.remove(fpath)
                deleted += 1

    print(f"[dump-vault] Done: {written} written, {deleted} deleted, {skipped} skipped")


if __name__ == "__main__":
    main()
